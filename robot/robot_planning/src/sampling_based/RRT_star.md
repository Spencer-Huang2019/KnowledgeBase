# 算法流程
1. 以起始点作为根节点建立一个棵搜索树  
2. 在空间中随机采样一个无碰撞的状态点 r  
3. 计算状态点 r 与树中最近的节点 near  
4. near 到 r 方向上，从 near 开始前进一个步长得到新的状态点 new  
5. 做碰撞检测：1）new 是否发生碰撞 2）从 near 到 new 连线中是否发生碰撞检测  
6. 发生碰撞，回到第 2 步重复  
7. 不发生碰撞，查找 new 一定半径范围内树上的候选 parents 节点，选择其中一个从根节点到 parent 再到 new 代价最小的节点为 new 的父节点  
8. rewiring：在 new 的多个候选 parents 节点中计算，是否先经过 new 在经过 parent 能获得更小的代价，若是，把 new 作为某个 parent 的父节点，
    而该 parent 节点作为叶子节点。  

# 思考
1. 第 7 步和第 8 步都是从 new 的候选 parents 里预连接去计算总代价。说真的，这两个的顺序好像有点问题吧。要是第 7 步找好了最优的 parent，
    第八步就应该只是决定是否要调换 new 和 parent。再从候选 parents 遍历一遍不就乱了么？  
    解答：事实上，只要理解了谁是父节点，谁是子节点以及父子节点 1 对多的关系，就能得出 7 和 8 步骤没问题的结论。  
2. 相比与 RRT，第 7 步和第 8 步是比较难理解的，刚学的时候有点绕不过弯。下边举个例子好好理解理解。


3. 对我来说，一开始感觉代码里最不好实现的是找最近点，总想着是不是可以用 KDTree，在聚类的时候用过 KDTree 的包，但是输入的是 pcl::PointCloud,
    不确定是不是还接受其他的数据类型。。。但无论如何还是得遍历一遍树的节点的。  
4. 这是整理的第一个算法，所以耗时确实长了一些，感觉其他的基于采样的算法应该能快一些。  
5. 步长、r 近邻的 r，最大迭代数，这些变量的值都有什么讲究呢？  


# 算法对比
